---
layout: default
title: 文件I/O第一篇
category: 技术文档
comments: true
---

**1.1 文件描述符** <br> 对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读或者写一个文件时，使用open或者creat返回的文件描述符标识该文件，将其作为参数传送给read或者write。UNIX系统shell使用文件描述符0与进程的标准输入相关联，文件描述符1与标准输出相关联，文件描述符2与标准出错输出相关联。<br> 依从POSIX的应用程序中，幻数0，1，2应当替换成符号常量STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO。这些常量都定义在头文件<unistd.h>中。<br>
**1.2 open函数**<br> 调用open函数可以打开或创建一个文件。<br>`#include<fcntl.h>`<br>`int open(const char *pathname,int oflag,.../* mode_t mode*/);`<br>返回值：若成功则返回文件描述符，若出错则返回-1.<br> 对于open函数而言，仅当创建新文件时才使用第三个参数。pathname是要打开或者创建文件的名字。oflag参数可用来说明此函数的多个选项。用下列一个或多个常量进行“或”运算构成oflag参数（这些常量定义在<fcntl.h>头文件中）：<br>O_RDONLY 只读打开。<br>O_WRONLY 只写打开。<br>O_RDWR 读，写打开。<br> 注：大多数实现将O_RDONLY定义为0，O_WRONLY定义为1，O_RDWR定义为2，以与早期的程序兼容.<br> 在这个三个常量中必须指定一个且只能指定一个。下列常量是可选择的：<br>O_APPEND 每次写时都追加到文件的尾端。<br>O_CREAT 若此文件不存在，则创建它。使用此选项时，需要第三个参数mode，用其指定改新文件的访问权限位。<br>O_EXCL 如果同时指定了O_CREAT,而文件已经存在，则会出错。用次可以测试一个文件是否存在，如果不存在，则创建次文件，这使测试和创建两者成为一个原子操作。<br>O_TRUNC 如果此文件存在，而且为只写或读写成功打开，则将其长度截断为0.<br>O_NOCTTY 如果pathname指的是终端设备，则不将设备分配作为此进程的控制终端。<br>O_NONBLOCK 如果pathname指的是一个FIFO，一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续I/0操作设置非阻塞模式。<br>由open返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在标准输入，标准输出或标准出错输出上打开新的文件。<br>**1.3** creat函数<br>可以调用creat函数创建一个新文件。<br>`#include<fcntl.h>`<br>`int creat(const char *pathname,mode_t mode);`<br>返回值：若成功则返回为只写打开的文件描述符，若出错则返回-1<br>注意，此函数等效于：<br> `open(pathname,O_WRONLY|O_CREAT|O_TRUNC,mode);`<br>creat的一个不足之处是它以只写方式打开所创建的文件。在提供open的新版本之前，如果要创建一个临时文件，并要先写该文件，然后又要读该文件，则必须先调用creat，close，然后再调用open。现在则可以用下列方式调用open：<br>`open(pathname,O_RDWR|O_CREAT|O_TRUNC,mode);`<br>**1.4 close函数**<br>可调用close函数关闭一个打开的文件：<br>`#include<unistd.h>`<br>`int close(int filedes);`<br> 返回值：若成功返回0，失败返回-1.<br> 关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有打开的文件。**1.5 lseek函数**<br>可以调用lseek显示地为一个打开的文件设置其偏移量。<br>`#include<unistd.h>`<br>`off_t lseek(int filedes,off_t offset,int whence);`<br> 返回值：若成功则返回新文件偏移量，若出错则返回-1.<br> 对于参数offset的解释与参数whence的值有关。<br> 
 ▪ 若whence是SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个字节。<br>
 ▪ 若whence是SEEK_CUR，则将该文件的偏移量设置为其当前值加offset，offset可以为正也可以为负。<br>
 ▪ 若whence是SEEK_END，则将该文件的偏移量设置为文件长度加offset，offset可以为正也可以为负。<br>若lseek成功执行,则返回新的文件偏移量，为此可以用下列方式确定打开文件的偏移量：<br>`off_t currpos;`<br>`currpos = lseek(ld,0,SEEK_CUR);`<br>这种方法也可以确定所涉及的文件是否可以设置偏移量。如果文件描述符引用的是一个管道，FIFO或网络套接字，怎lseek返回-1，并将errno设置为ESPIPE。<br>`#include"apue.h"`<br>`int main(void)`<br>`{`<br> `if (lseek(STDIN_FILENO,0,SEEK_CUR) == -1)`<br> ` printf("cannot seek\n");` <br> `else`<br> ` printf("seek OK\n");`<br> `exit(0);`<br>`}`<br>lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作。然后，该偏移量用于下一个读或者写操作。<br>
  文件偏移量可以大于文件的当前长度，这样，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0.<br> 文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于源文件尾端和新开始写位置之间的部分则不需要分配磁盘块。<br> # 创建具有空洞的文件。 #<br>`#include"apue.h"`<br>`#include<fcntl.h>`<br>`char buf1[] = "abcdefghij";`<br>`char buf2[] = "ABCDEFGHIJ";`<br>`int main(void){`<br>`	int fd;`<br>`	if ((fd = creat("file.hole",FILE_MODE)) < 0)`<br>`err_sys("creat error");`<br>`if(write(fd,buf1,10) != 10)`<br>`err_sys("buf1 write error");`<br>`if(lseek(fd,10240,SEEK_SET) == -1)`<br>`err_sys("lseek error");`<br>`if(write(fd,buf2,10) != 10)`<br>`err_sys("buf2 write error");`<br>`exit(0)`<br>`}`<br>**1.6 read函数 **<br> 调用read函数从打开文件中读数据。<br>`#include<unistd.h>`<br>`ssize_t read(int filedes,void *buf,size_t nbytes);`<br> 返回值：若成功则返回读到的字节数，若已到文件结尾则返回0，若出错则返回-1.<br>如read成功，则返回读到的字节数。如已到达文件结尾，则返回0.<br>有多种情况可使实际读到的字节数少于要求读的字节数：<br>
1. 读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前还有30个字节，而要求读100个字节，则read返回30，下次在调用read时，它将返回0（文件尾端）。<br>
2. 当从终端设备读时，通常一次最多读一行。<br>
3. 当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数。<br>
4. 当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。<br>
5. 当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。<br>
6. 当某一信号造成中断，而已经读了部分数据量时。<br>
POSIX.1从几个方面对read函数的原型作了更改。其定义：<br>
1. 首先，为了与ISO C保持一致，将第二个参数由char * 改为void*。在ISO C中，类型void*用于表示通用指针。<br>
2. 其次，其返回值必须是一个带符号整数（ssize_t）,以返回正字节数，0（表示文件尾端）或-1（出错）。<br>
3. 最后，第三个参数在历史上是一个不带符号整数，这允许一个16位的实现一次读或写的数据可以多达65534个字节。在1999 POSIX.1标准中，引入了基本系统数据类型ssize_t以提供带符号的返回值，不带符号的size_t则用于第三个参数。<br>
